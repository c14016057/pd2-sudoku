一、解題
基本解法和老師的一樣，由第一格開始填1~9但並非把整個數獨填完才檢查是否正確，每填一個數字就檢查一次同行同列同塊間有沒有重複以節省時間，另外一個加快計算時間的方法寫在simplify()內每成功填一個數字都呼叫此函數一次，此函數是模擬人類玩數獨時的解法，舉個例子如下:
以9*9為例假如有個數獨左邊三塊如下
1 0 0
0 0 0
0 0 0

0 2 0
0 a 0
0 3 0

0 0 0
0 0 0
0 0 1
因為一、三行都有1，所以中間那塊的1必定在第二行的三個空位中，又因為此行已經填了兩個數字所以只剩下a的位置可以填。
又或者
0 0 0
1 0 0
0 0 0

0 0 0
0 0 0
0 0 1

0 0 0  0 0 0  1 0 0 
0 0 0  0 1 0  0 0 0
0 a 0  0 0 0  0 0 0
由於一三行和七八列的1始得最左下那塊1只有a的位置可以填。
把這種可以簡單判斷並且確定位置的數字計算出來可以節約很多時間。
具體實施方法是用9個144格的輔助陣列初始化為0，每個陣列負責1~9其中一個數，假如題目中第一格是8那麼就把對應8的那個輔助陣列的第一塊第一行第一列都填1，其它所有輔助陣列則把第一格填1，當把題目掃過一變後在回來看輔助陣列中有沒有哪一格哪一行哪一列中只有恰恰一個0，且此位置對應題目內的位置還沒被填，如果有，此格就確定為該輔助陣列所對應的數字。
二、出題
先找一個9*9的題目，擴充成12*12，把題目內的數字互相對調(譬如所有1和所有2交換位置)即可產生新的題目。
